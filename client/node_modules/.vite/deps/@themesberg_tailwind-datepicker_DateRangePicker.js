import {
  Datepicker,
  formatDate,
  registerListeners,
  unregisterListeners
} from "./chunk-GBYYJAOT.js";
import "./chunk-5CYG367S.js";

// node_modules/@themesberg/tailwind-datepicker/js/DateRangePicker.js
function filterOptions(options) {
  const newOpts = Object.assign({}, options);
  delete newOpts.inputs;
  delete newOpts.allowOneSidedRange;
  delete newOpts.maxNumberOfDates;
  return newOpts;
}
function setupDatepicker(rangepicker, changeDateListener, el, options) {
  registerListeners(rangepicker, [
    [el, "changeDate", changeDateListener]
  ]);
  new Datepicker(el, options, rangepicker);
}
function onChangeDate(rangepicker, ev) {
  if (rangepicker._updating) {
    return;
  }
  rangepicker._updating = true;
  const target = ev.target;
  if (target.datepicker === void 0) {
    return;
  }
  const datepickers = rangepicker.datepickers;
  const setDateOptions = { render: false };
  const changedSide = rangepicker.inputs.indexOf(target);
  const otherSide = changedSide === 0 ? 1 : 0;
  const changedDate = datepickers[changedSide].dates[0];
  const otherDate = datepickers[otherSide].dates[0];
  if (changedDate !== void 0 && otherDate !== void 0) {
    if (changedSide === 0 && changedDate > otherDate) {
      datepickers[0].setDate(otherDate, setDateOptions);
      datepickers[1].setDate(changedDate, setDateOptions);
    } else if (changedSide === 1 && changedDate < otherDate) {
      datepickers[0].setDate(changedDate, setDateOptions);
      datepickers[1].setDate(otherDate, setDateOptions);
    }
  } else if (!rangepicker.allowOneSidedRange) {
    if (changedDate !== void 0 || otherDate !== void 0) {
      setDateOptions.clear = true;
      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
    }
  }
  datepickers[0].picker.update().render();
  datepickers[1].picker.update().render();
  delete rangepicker._updating;
}
var DateRangePicker = class {
  constructor(element, options = {}) {
    const inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
    if (inputs.length < 2) {
      return;
    }
    element.rangepicker = this;
    this.element = element;
    this.inputs = inputs.slice(0, 2);
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    const changeDateListener = onChangeDate.bind(null, this);
    const cleanOptions = filterOptions(options);
    const datepickers = [];
    Object.defineProperty(this, "datepickers", {
      get() {
        return datepickers;
      }
    });
    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
    Object.freeze(datepickers);
    if (datepickers[0].dates.length > 0) {
      onChangeDate(this, { target: this.inputs[0] });
    } else if (datepickers[1].dates.length > 0) {
      onChangeDate(this, { target: this.inputs[1] });
    }
  }
  get dates() {
    return this.datepickers.length === 2 ? [
      this.datepickers[0].dates[0],
      this.datepickers[1].dates[0]
    ] : void 0;
  }
  setOptions(options) {
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    const cleanOptions = filterOptions(options);
    this.datepickers[0].setOptions(cleanOptions);
    this.datepickers[1].setOptions(cleanOptions);
  }
  destroy() {
    this.datepickers[0].destroy();
    this.datepickers[1].destroy();
    unregisterListeners(this);
    delete this.element.rangepicker;
  }
  getDates(format = void 0) {
    const callback = format ? (date) => formatDate(date, format, this.datepickers[0].config.locale) : (date) => new Date(date);
    return this.dates.map((date) => date === void 0 ? date : callback(date));
  }
  setDates(rangeStart, rangeEnd) {
    const [datepicker0, datepicker1] = this.datepickers;
    const origDates = this.dates;
    this._updating = true;
    datepicker0.setDate(rangeStart);
    datepicker1.setDate(rangeEnd);
    delete this._updating;
    if (datepicker1.dates[0] !== origDates[1]) {
      onChangeDate(this, { target: this.inputs[1] });
    } else if (datepicker0.dates[0] !== origDates[0]) {
      onChangeDate(this, { target: this.inputs[0] });
    }
  }
};

// dep:@themesberg_tailwind-datepicker_DateRangePicker
var themesberg_tailwind_datepicker_DateRangePicker_default = DateRangePicker;
export {
  themesberg_tailwind_datepicker_DateRangePicker_default as default
};
//# sourceMappingURL=@themesberg_tailwind-datepicker_DateRangePicker.js.map
